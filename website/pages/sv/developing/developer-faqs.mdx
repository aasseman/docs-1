---
title: Vanliga frågor för utvecklare
---

## 1. Vad är en subgraf?

En subgraf är en anpassad API byggd på blockkedjedata. Subgrafer frågas med hjälp av GraphQL-frågespråket och distribueras till en Graph Node med hjälp av Graph CLI. När de har distribuerats och publicerats till The Graphs decentraliserade nätverk, bearbetar Indexers subgrafer och gör dem tillgängliga för frågekonsumenter av subgrafer.

## 2. Kan jag ta bort min subgraf?

Det är inte möjligt att ta bort subgrafer efter att de har skapats.

## 3. Kan jag ändra namnet på min subgraf?

Nej. När en subgraf har skapats kan namnet inte ändras. Se till att tänka noga på detta innan du skapar din subgraf så att den är lätt sökbar och identifierbar av andra dappar.

## 4. Kan jag ändra det GitHub-konto som är kopplat till min subgraf?

Nej. När en subgraf har skapats kan det associerade GitHub-kontot inte ändras. Tänk noggrant på detta innan du skapar din subgraf.

## 5. Kan jag fortfarande skapa en subgraf om mina smarta kontrakt inte har händelser?

Det rekommenderas starkt att strukturera dina smarta kontrakt så att de har händelser som är kopplade till data du är intresserad av att fråga. Händelsehanterare i subgrafen utlöses av kontrakthändelser och är överlägset det snabbaste sättet att hämta användbar data.

Om de kontrakt du arbetar med inte innehåller händelser kan din subgraf använda sig av uppropshanterare och blockhanterare för att utlösa indexering. Detta rekommenderas dock inte, eftersom prestandan kommer att vara betydligt långsammare.

## 6. How are templates different from data sources?

Mallar låter dig skapa datakällor på flykt medan din subgraf indexerar. Det kan vara så att ditt kontrakt kommer att skapa nya kontrakt när människor interagerar med det, och eftersom du känner till formen av dessa kontrakt (ABI, händelser osv.) i förväg kan du definiera hur du vill indexera dem i en mall och när de skapas kommer din subgraf att skapa en dynamisk datakälla genom att tillhandahålla kontraktsadressen.

Kolla in avsnittet "Instansiera en mall för datakälla" på: [Mallar för datakällor](/developing/creating-a-subgraph#data-source-templates).

## 7. How do I make sure I'm using the latest version of graph-node for my local deployments?

Du kan köra följande kommando:

```sh
docker pull graphprotocol/graph-node:latest
```

**OBS:** Docker / docker-compose kommer alltid att använda den graph-node-version som hämtades första gången du körde det, så det är viktigt att göra detta för att se till att du är uppdaterad med den senaste versionen av graph-node.

## 8. How do I call a contract function or access a public state variable from my subgraph mappings?

Take a look at `Access to smart contract` state inside the section [AssemblyScript API](/developing/graph-ts/api/#access-to-smart-contract-state).

## 9. Is it possible to set up a subgraph using `graph init` from `graph-cli` with two contracts? Or should I manually add another datasource in `subgraph.yaml` after running `graph init`?

Yes. On `graph init` command itself you can add multiple datasources by entering contracts one after the other. You can also use `graph add` command to add new datasource.

## 10. I want to contribute or add a GitHub issue. Where can I find the open source repositories?

- [graph-node](https://github.com/graphprotocol/graph-node)
- [graph-tooling](https://github.com/graphprotocol/graph-tooling)
- [graph-docs](https://github.com/graphprotocol/docs)
- [graph-client](https://github.com/graphprotocol/graph-client)

## 11. What is the recommended way to build "autogenerated" ids for an entity when handling events?

Om endast en entitet skapas under händelsen och om inget bättre är tillgängligt, skulle transaktionshashen + loggindexet vara unikt. Du kan förvränga dessa genom att konvertera dem till bytes och sedan skicka dem genom `crypto.keccak256`, men detta kommer inte att göra dem mer unika.

## 12. When listening to multiple contracts, is it possible to select the contract order to listen to events?

Inom en subgraf behandlas händelser alltid i den ordning de visas i blocken, oavsett om det är över flera kontrakt eller inte.

## 13. Is it possible to differentiate between networks (mainnet, Sepolia, local) from within event handlers?

Ja, du kan göra detta genom att importera `graph-ts` enligt exemplet nedan:

```javascript
import { dataSource } from "@graphprotocol/graph-ts"

dataSource.network()
dataSource.address()
```

## 14. Do you support block and call handlers on Sepolia?

Yes. Sepolia supports block handlers, call handlers and event handlers. It should be noted that event handlers are far more performant than the other two handlers, and they are supported on every EVM-compatible network.

## 15. Can I import ethers.js or other JS libraries into my subgraph mappings?

För närvarande inte, eftersom mappningar är skrivna i AssemblyScript. En möjlig alternativ lösning på detta är att lagra rådata i enheter och utföra logik som kräver JS-bibliotek på klienten.

## 16. Is it possible to specify what block to start indexing on?

Yes. `dataSources.source.startBlock` in the `subgraph.yaml` file specifies the number of the block that the data source starts indexing from. In most cases, we suggest using the block in which the contract was created: [Start blocks](/developing/creating-a-subgraph#start-blocks)

## 17. Are there some tips to increase the performance of indexing? My subgraph is taking a very long time to sync

Ja, du bör titta på den valfria funktionen för startblock för att börja indexera från det block där kontraktet distribuerades: [Start blocks](/developing/creating-a-subgraph#start-blocks)

## 18. Is there a way to query the subgraph directly to determine the latest block number it has indexed?

Ja! Prova följande kommando och ersätt "organization/subgraphName" med organisationen under vilken den är publicerad och namnet på din subgraf:

```sh
curl -X POST -d '{ "query": "{indexingStatusForCurrentVersion(subgraphName: \"organization/subgraphName\") { chains { latestBlock { hash number }}}}"}' https://api.thegraph.com/index-node/graphql
```

## 19. What networks are supported by The Graph?

Du kan hitta listan över de stödda nätverken [här](/developing/supported-networks).

## 20. Is it possible to duplicate a subgraph to another account or endpoint without redeploying?

Du måste distribuera om subgrafen, men om subgrafens ID (IPFS-hash) inte ändras behöver den inte synkroniseras från början.

## 21. Is this possible to use Apollo Federation on top of graph-node?

Federation stöds ännu inte, även om vi planerar att stödja det i framtiden. För närvarande kan du använda schema stitching, antingen på klienten eller via en proxytjänst.

## 22. Is there a limit to how many objects The Graph can return per query?

Som standard är frågesvar begränsade till 100 objekt per samling. Om du vill ha fler kan du gå upp till 1000 objekt per samling och bortom det kan du paginera med:

```graphql
someCollection(first: 1000, skip: <number>) { ... }
```

## 23. If my dapp frontend uses The Graph for querying, do I need to write my query key into the frontend directly? What if we pay query fees for users – will malicious users cause our query fees to be very high?

För närvarande är det rekommenderade tillvägagångssättet för en dapp att lägga till nyckeln i frontänden och exponera den för slutanvändare. Med det sagt kan du begränsa den nyckeln till en värdnamn, som _yourdapp.io_ och subgraphen. Gatewayen drivs för närvarande av Edge & Node. En del av gatewayens ansvar är att övervaka missbruk och blockera trafik från skadliga klienter.

## 24. How do I update a subgraph on mainnet?

If you’re a subgraph developer, you can deploy a new version of your subgraph to Subgraph Studio using the CLI. It’ll be private at that point, but if you’re happy with it, you can publish to the decentralized Graph Explorer. This will create a new version of your subgraph that Curators can start signaling on.

## 25. In what order are the event, block, and call handlers triggered for a data source?

Event and call handlers are first ordered by transaction index within the block. Event and call handlers within the same transaction are ordered using a convention: event handlers first then call handlers, each type respecting the order they are defined in the manifest. Block handlers are run after event and call handlers, in the order they are defined in the manifest. Also these ordering rules are subject to change.

When new dynamic data source are created, the handlers defined for dynamic data sources will only start processing after all existing data source handlers are processed, and will repeat in the same sequence whenever triggered.
