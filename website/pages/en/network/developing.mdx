---
title: Developing
---

Learn developer fundamentals and review the basics of a subgraph’s lifecycle. To start coding right away and build on The Graph, go to [Developer Quick Start](/quick-start/)

## Overview

As a developer, you need important data to build and power your dapps. Querying and indexing that blockchain data can be challenging, but The Graph provides a solution to this issue.

On The Graph, you can:

1.  Create, deploy and publish subgraphs to The Graph using **Graph CLI** and [Subgraph Studio](https://thegraph.com/studio/).
2.  Use GraphQL to query live subgraphs and power dapps.

### What is GraphQL?

- [GraphQL](/querying/graphql-api/)is the query language for APIs and a runtime for executing those queries with your existing data. The Graph uses GraphQL to query subgraphs.

### Developer Capabilities

- Query subgraphs built by other developers in [The Graph Network](https://thegraph.com/explorer) and integrate them into your own dapps.
- Create custom subgraphs to fulfill specific data needs, allowing improved scalability and flexibility for other developers.
- Deploy, publish, and signal your subgraphs within The Graph Network.

## Subgraph Specifics

### What are subgraphs?

A subgraph is a custom API built on blockchain data. It extracts data from a blockchain, processes it, and stores it so that it can be easily queried via GraphQL.

A subgraph primarily consists of the following files:

- `subgraph.yaml`: this YAML file contains the [subgraph manifest](/developing/creating-a-subgraph/#the-subgraph-manifest)
- `subgraph.graphql`: this GraphQL schema defines what data is stored for your subgraph, and how to query it via [GraphQL](/developing/creating-a-subgraph/#the-graphql-schema)
- `AssemblyScript Mappings`: [AssemblyScript](https://github.com/AssemblyScript/assemblyscript) mappings translates data from the event data to the entities defined in your schema

Learn the detailed specifics to [create a subgraph](/developing/creating-a-subgraph/).

### Subgraph Lifecycle

Here is a general view of a subgraph’s cycle:

![Subgraph Lifecycle](/img/subgraph-lifecycle.png)

### Context for Subgraph Development

Great subgraphs start with a local development environment and unit tests. Developers can use `graph-cli,` `graph-ts,` and [Matchstick](/developing/unit-testing-framework/) to build robust subgraphs that deploy to The Graph Network.

> Developers use [Graph CLI](https://github.com/graphprotocol/graph-tooling/tree/main/packages/cli), a command line interface tool for building and deploying subgraphs in The Graph.

## Deploy to Subgraph Studio

Once defined, a subgraph can be deployed to [Subgraph Studio](/deploying/deploying-a-subgraph-to-studio/). In Subgraph Studio, you can do the following:

- Use its staging environment to index the deployed subgraph and make it available for review.
- Verify that your subgraph doesn't have any indexing errors and works as expected.

## Publish to the Network

When you are happy with your subgraph, you can [publish it](/publishing/publishing-a-subgraph/) to The Graph Network.

- To put your subgraph into production and ensure indexers can index it, you must publish it to The Graph Network.
  - This is an on-chain action, which registers the subgraph and makes it discoverable by Indexers.
- Published subgraphs have a corresponding NFT, which is then easily transferable.
- Published subgraphs have associated metadata, which provides other network participants with useful context and information.

## Add Signal for Indexing

Published subgraphs are unlikely to be picked up by Indexers without signal. To encourage indexing you should add signal to your subgraph. Learn more about signaling and [curating](/network/curating/) on The Graph.

### What is signal?

- Signal is locked GRT associated with a given subgraph. It indicates to indexers that a given subgraph will receive query volume and it contributes to the indexing rewards available for processing it.
- Third party Curators may also signal on a given subgraph, if they deem the subgraph likely to drive query volume.

## Querying & Application Development

Once a subgraph has been processed by Indexers and is ready to [query](/querying/querying-the-graph/), developers can start using their subgraph in their dapps.

- When a query is made, The Graph Network selects an Indexer who has processed the subgraph to serve that query. Query fees are paid in GRT.
- Developers must generate an API key and fund it with GRT to make queries, which can be done in [Subgraph Studio](https://thegraph.com/studio/).
- Developers can set a maximum query fee, in order to control their costs, and limit their API key to a given subgraph or origin domain.
  - Subgraph Studio provides API key usage data.
- Developers can express an Indexer preference to the gateway, for example preferring Indexers whose query response is faster, or whose data is most up to date. These controls are set in Subgraph Studio.

## Updating Subgraphs

To update your subgraph with bug fixes or new functionalities, initiate a transaction to point it to the new version. You can deploy new versions of your subgraphs to [Subgraph Studio](https://thegraph.com/studio/) for development and testing.

- If you selected "auto-migrate" when you applied the signal, updating the subgraph will migrate any signal to the new version and incur a migration tax.
- This signal migration should prompt Indexers to start indexing the new version of the subgraph, so it should soon become available for querying.

## Deprecating & Transferring Subgraphs

If you no longer need a published subgraph, you can deprecate or transfer a subgraph. Deprecating a subgraph returns any signaled GRT to [Curators](/network/curating/).

- To deprecate or transfer a subgraph, check out [this guide](/managing/transfer-and-deprecate-a-subgraph/#deprecating-a-subgraph).

## Network Economics

As a developer, you can do any of the following:

- Lock up GRT to encourage indexing and querying subgraphs.
- Burn GRT whenever a subgraph is updated.
