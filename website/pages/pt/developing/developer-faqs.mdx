---
title: Perguntas Frequentes dos Programadores
---

## 1. O que é um subgraph?

Um subgraph é uma API personalizada construída em dados de blockchains. Subgraphs são consultados com a linguagem GraphQL e lançados a um Graph Node usando o Graph CLI. Quando lançados e editados à rede descentralizada do The Graph, os Indexadores processam subgraphs e os disponibilizam para serem consultados em query por consumidores de subgraphs.

## 2. Posso apagar o meu subgraph?

Não é possível apagar subgraphs após a sua criação.

## 3. Posso mudar o nome do meu subgraph?

Não. Quando um subgraph é criado, não é possível mudar o seu nome. Pense com cuidado antes de criar o seu subgraph para poder ser facilmente buscável e identificável por outros dapps.

## 4. Posso mudar a conta do GitHub associada ao meu subgraph?

Não. Quando um subgraph é criado, não há mais como mudar a conta do GitHub associada a ele. Pense nisto com cuidado antes de criar o seu subgraph.

## 5. Eu ainda posso criar um subgraph se os meus contratos inteligentes não tiverem eventos?

É altamente recomendado que estruture os seus contratos inteligentes para terem eventos associados com dados que tens interesse de consultar em query. Handlers de eventos no subgraph são ativados por eventos de contratos e são, de longe, a forma mais rápida de conseguir dados úteis.

Se os contratos com os quais trabalha não contêm eventos, o seu subgraph pode usar handlers de chamadas e blocos para ativar o indexing. Porém, isto não é recomendado, porque retarda muito o desempenho do subgraph.

## 6. How are templates different from data sources?

Modelos (templates) permitem criar fontes de dados na hora, enquanto o seu subgraph está no processo de indexação. Pode ser que o seu contrato gerará novos contratos enquanto as pessoas interagem com ele, e como queres saber o formato destes contratos (ABI, eventos, etc.) à vista, pode definir como quer indexá-los em um modelo; e quando gerados, o seu subgraph criará uma fonte de dados dinâmica ao fornecer o endereço do contrato.

Confira a seção "como instanciar um modelo de fontes de dados" em: [Modelos de fontes de dados](/developing/creating-a-subgraph#data-source-templates).

## 7. How do I make sure I'm using the latest version of graph-node for my local deployments?

Podes executar o seguinte comando:

```sh
docker pull graphprotocol/graph-node:latest
```

**NOTA:** O docker / docker-compose sempre usará a versão do graph-node que foi puxada na primeira vez que a executou, então é importante fazer isto para garantir que está em dia com a versão mais recente do graph-node.

## 8. How do I call a contract function or access a public state variable from my subgraph mappings?

Confira o estado `Access to smart contract` dentro da seção [AssemblyScript API](/developing/graph-ts/api/#access-to-smart-contract-state).

## 9. Is it possible to set up a subgraph using `graph init` from `graph-cli` with two contracts? Or should I manually add another datasource in `subgraph.yaml` after running `graph init`?

Sim. No próprio comando `graph init`, é possível adicionar várias fontes de dados ao inserir contratos um após o outro. O comando `graph add` também pode adicionar uma nova fonte de dados.

## 10. I want to contribute or add a GitHub issue. Where can I find the open source repositories?

- [graph-node](https://github.com/graphprotocol/graph-node)
- [graph-tooling](https://github.com/graphprotocol/graph-tooling)
- [graph-docs](https://github.com/graphprotocol/docs)
- [graph-client](https://github.com/graphprotocol/graph-client)

## 11. What is the recommended way to build "autogenerated" ids for an entity when handling events?

Se só uma entidade for criada durante o evento e não houver nada melhor disponível, então o hash da transação + o index do log será original. Podes ofuscá-los ao converter aquilo em Bytes e então o colocar pelo `crypto.keccak256`, mas isto não o fará mais original.

## 12. When listening to multiple contracts, is it possible to select the contract order to listen to events?

Dentro de um subgraph, os eventos são sempre processados na ordem em que aparecem nos blocos, mesmo sendo ou não através de vários contratos.

## 13. Is it possible to differentiate between networks (mainnet, Sepolia, local) from within event handlers?

Sim. Isto é possível ao importar o `graph-ts` como no exemplo abaixo:

```javascript
import { dataSource } from '@graphprotocol/graph-ts'

dataSource.network()
dataSource.address()
```

## 14. Do you support block and call handlers on Sepolia?

Sim. O Sepolia apoia handlers de blocos, chamadas e eventos. Vale notar que handlers de eventos têm desempenho muito melhor do que os outros dois e têm apoio em todas as redes compatíveis com EVMs.

## 15. Can I import ethers.js or other JS libraries into my subgraph mappings?

Não no momento, já que mapeamentos são escritos em AssemblyScript. Outra solução seria armazenar dados puros em entidades e desempenhar lógicas que requerem bibliotecas JS no cliente.

## 16. Is it possible to specify what block to start indexing on?

Sim. `dataSources.source.startBlock` no arquivo `subgraph.yaml` especifica o número do bloco que a fonte de dados começa a indexar. Na maioria dos casos, sugerimos usar o bloco no qual o contrato foi criado: [Blocos de início](/developing/creating-a-subgraph#start-blocks)

## 17. Are there some tips to increase the performance of indexing? My subgraph is taking a very long time to sync

Sim. Confira o recurso opcional de bloco inicial (start blcok) para começar a indexar do bloco em que o contrato foi lançado: [Blocos iniciais](/developing/creating-a-subgraph#start-blocks)

## 18. Is there a way to query the subgraph directly to determine the latest block number it has indexed?

Sim! Execute o seguinte comando, com "organization/subgraphName" substituído com a organização sob a qual ele foi publicado e o nome do seu subgraph:

```sh
curl -X POST -d '{ "query": "{indexingStatusForCurrentVersion(subgraphName: \"organization/subgraphName\") { chains { latestBlock { hash number }}}}"}' https://api.thegraph.com/index-node/graphql
```

## 19. What networks are supported by The Graph?

Veja a lista das redes apoiadas [aqui](/developing/supported-networks).

## 20. Is it possible to duplicate a subgraph to another account or endpoint without redeploying?

Deve relançar o subgraph, mas se a ID do subgraph (hash IPFS) não mudar, ele não precisará sincronizar do começo.

## 21. Is this possible to use Apollo Federation on top of graph-node?

A Federation ainda tem apoio, mas queremos apoiá-la no futuro. No momento, vale usar costura de schemas no cliente ou através de um serviço proxy.

## 22. Is there a limit to how many objects The Graph can return per query?

Normalmente, respostas a consultas são limitadas a 100 itens por coleção. Se quiser receber mais, pode subir para até 1000 itens por coleção; além disto, pode paginar com:

```graphql
someCollection(first: 1000, skip: <number>) { ... }
```

## 23. If my dapp frontend uses The Graph for querying, do I need to write my query key into the frontend directly? What if we pay query fees for users – will malicious users cause our query fees to be very high?

Atualmente, a abordagem recomendada para um dApp é adicionar a chave ao frontend e expô-la para utilizadores finais. Dito isto, pode limitar aquela chave a um hostname, como _seudapp.io_ e um subgraph. A gateway está atualmente a ser executada pelo Edge & Node. Parte da responsabilidade de uma gateway é monitorar comportamentos abusivos e bloquear tráfego de clientes maliciosos.

## 24. How do I update a subgraph on mainnet?

Se for um programador de subgraph, você pode lançar uma nova versão do seu subgraph ao Subgraph Studio com a CLI. O subgraph será privado até lá, mas se estiver contente com ele, você pode publicá-lo no Graph Explorer descentralizado. Isto criará uma nova versão do seu subgraph em que Curadores podem começar a sinalizar.

## 25. In what order are the event, block, and call handlers triggered for a data source?

Primeiro, handlers de eventos e chamadas são organizados pelo índice de transações dentro do bloco. Handlers de evento e chamada dentro da mesma transação são organizados com uma convenção: handlers de eventos primeiro e depois handlers de chamadas, com cada tipo a respeitar a ordem em que são definidos no manifest. Handlers de blocos são executados após handlers de eventos e chamadas, na ordem em que são definidos no manifest. Estas regras de organizações estão sujeitas a mudanças.

Com a criação de novas fontes de dados dinâmicas, os handlers definidos para fontes de dados dinâmicas só começarão a processar após o processamento dos handlers das fontes, e se repetirão na mesma sequência sempre que acionados.
